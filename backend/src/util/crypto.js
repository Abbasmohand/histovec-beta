import crypto from 'crypto'

// @todo: remove type check while using joi validation
export const checkUuid = (uuid) =>
  typeof uuid === 'string' && uuid && String.prototype.match.call(uuid, /[a-f0-9]{8}-([a-f0-9]{4}-){3}[a-f0-9]{12}/)

export const checkId = (id) =>
  typeof id === 'string' && id && id.match(/[A-Za-z0-9_-]{43}=/)

export const urlSafeBase64Encode = (text) => {
  const urlUnsafeBase64Encoded = Buffer.from(text).toString('base64')

  // Equivalent to replace(/\+/g, '-').replace(/\//g, '_') but faster
  return urlUnsafeBase64Encoded.replace(/[+/]/g, char => char === '+' ? '-' : '_')
}

/*
  Equivalent of dataprep Python function :

  def hash(text):
    return base64.urlsafe_b64encode(
      hashlib.sha256(text).digest()
    )
*/
export const hash = (text) => urlSafeBase64Encode(
  crypto.createHash('sha256').update(text).digest()
)

// weak encryption (used for encryptedImmat)
export const decryptXOR = (encrypted, key) => String.fromCharCode(
  ...Buffer.from(encrypted, 'base64')
    .map((char, index) => char ^ key.charCodeAt(index % key.length))
)

/*
  Equivalent of dataprep Python function :

  def encrypt_string(key, string):
    padded = pad(string)
    iv = Random.new().read(AES.block_size)
    cipher = AES.new(key, AES.MODE_CBC, iv)
    return base64.urlsafe_b64encode(iv + cipher.encrypt(padded))

  encrypt_string(hash(key), data)

  --------------
  Inspirations :
  https://www.semicolonworld.com/question/46424/encrypting-and-decrypting-with-python-and-nodejs#comment-21
  https://nodejs.org/en/knowledge/cryptography/how-to-use-crypto-module/#ciphers

  Algorithm   Key (generated by frontend)   iv
  aes256cbc   32 byte (256 bits)            16 byte (128 bits)
*/
const AES_ALGORITHM = 'aes-256-cbc'
const AES_BLOCK_SIZE = 16

const encrypt = (input, key) => {
  const iv = crypto.randomBytes(AES_BLOCK_SIZE)
  const cipher = crypto.createCipheriv(AES_ALGORITHM, key, iv)

  const encrypted = Buffer.concat([
    cipher.update(Buffer.from(input, 'utf8')),
    cipher.final(),
  ])

  return urlSafeBase64Encode(Buffer.concat([iv, encrypted]))
}

export const encryptJson = (json, key) => encrypt(JSON.stringify(json), key)
